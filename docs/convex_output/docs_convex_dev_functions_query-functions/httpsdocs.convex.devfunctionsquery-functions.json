[
    {
        "url": "https://docs.convex.dev/functions/query-functions",
        "content": "# Queries\nQueries are the bread and butter of your backend API. They fetch data from the database, check authentication or perform other business logic, and return data back to the client application.\n\nThis is an example query, taking in named arguments, reading data from the database and returning a result:\n\n`import { query } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\n// Return the last 100 tasks in a given task list.\nexport const getTaskList = query({\nargs: { taskListId: v.id(\"taskLists\") },\nhandler: async (ctx, args) => {\nconst tasks = await ctx.db\n.query(\"tasks\")\n.filter((q) => q.eq(q.field(\"taskListId\"), args.taskListId))\n.order(\"desc\")\n.take(100);\nreturn tasks;\n},\n});\nRead on to understand how to build queries yourself.\n\n## Query names[](#query-names)\nQueries are defined in\n\n`convex/`\ndirectory.\nThe path and name of the file, as well as the way the function is exported from the file, determine the name the client will use to call it:\n\n`// This function will be referred to as `api.myFunctions.myQuery`.`\nexport const myQuery = …;\n// This function will be referred to as `api.myFunctions.sum`.\nexport const sum = …;\nTo structure your API you can nest directories inside the `convex/`\ndirectory:\n\n`// This function will be referred to as `api.foo.myQueries.listMessages`.`\nexport const listMessages = …;\nDefault exports receive the name `default`\n.\n\n`// This function will be referred to as `api.myFunctions.default`.`\nexport default …;\nThe same rules apply to [mutations](/functions/mutation-functions) and\n[actions](/functions/actions), while\n[HTTP actions](/functions/http-actions) use a different routing\napproach.\n\nClient libraries in languages other than JavaScript and TypeScript use strings instead of API objects:\n\n`api.myFunctions.myQuery`\nis`\"myFunctions:myQuery\"`\n`api.foo.myQueries.myQuery`\nis`\"foo/myQueries:myQuery\"`\n.`api.myFunction.default`\nis`\"myFunction:default\"`\nor`\"myFunction\"`\n.\n## The `query`\nconstructor[](#the-query-constructor)\nTo actually declare a query in Convex you use the `query`\nconstructor function.\nPass it an object with a `handler`\nfunction, which returns the query result:\n\n`import { query } from \"./_generated/server\";`\nexport const myConstantString = query({\nhandler: () => {\nreturn \"My never changing string\";\n},\n});\n### Query arguments[](#query-arguments)\nQueries accept named arguments. The argument values are accessible as fields of the second parameter of the handler function:\n\n`import { query } from \"./_generated/server\";`\nexport const sum = query({\nhandler: (_, args: { a: number; b: number }) => {\nreturn args.a + args.b;\n},\n});\nArguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your query.\n\nTo both declare the types of arguments and to validate them, add an `args`\nobject using `v`\nvalidators:\n\n`import { query } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\nexport const sum = query({\nargs: { a: v.number(), b: v.number() },\nhandler: (_, args) => {\nreturn args.a + args.b;\n},\n});\nSee [argument validation](/functions/validation) for the full list of\nsupported types and validators.\n\nThe first parameter of the handler function contains the query context.\n\n### Query responses[](#query-responses)\nQueries can return values of any supported\n[Convex type](/functions/validation) which will be automatically\nserialized and deserialized.\n\nQueries can also return `undefined`\n, which is not a valid Convex value. When a\nquery returns `undefined`\n**it is translated to null** on the client.\n\n### Query context[](#query-context)\nThe `query`\nconstructor enables fetching data, and other Convex features by\npassing a [QueryCtx](/generated-api/server#queryctx) object to the\nhandler function as the first parameter:\n\n`import { query } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\nexport const myQuery = query({\nargs: { a: v.number(), b: v.number() },\nhandler: (ctx, args) => {\n// Do something with `ctx`\n},\n});\nWhich part of the query context is used depends on what your query needs to do:\n\n-\nTo fetch from the database use the\n\n`db`\nfield. Note that we make the handler function an`async`\nfunction so we can`await`\nthe promise returned by`db.get()`\n:convex/myFunctions.tsTS`import { query } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\nexport const getTask = query({\nargs: { id: v.id(\"tasks\") },\nhandler: async (ctx, args) => {\nreturn await ctx.db.get(args.id);\n},\n});Read more about\n\n[Reading Data](/database/reading-data). -\nTo return URLs to stored files use the\n\n`storage`\nfield. Read more about[File Storage](/file-storage). -\nTo check user authentication use the\n\n`auth`\nfield. Read more about[Authentication](/auth).\n## Splitting up query code via helpers[](#splitting-up-query-code-via-helpers)\nWhen you want to split up the code in your query or reuse logic across multiple Convex functions you can define and call helper\n\n`import { Id } from \"./_generated/dataModel\";`\nimport { query, QueryCtx } from \"./_generated/server\";\nimport { v } from \"convex/values\";\nexport const getTaskAndAuthor = query({\nargs: { id: v.id(\"tasks\") },\nhandler: async (ctx, args) => {\nconst task = await ctx.db.get(args.id);\nif (task === null) {\nreturn null;\n}\nreturn { task, author: await getUserName(ctx, task.authorId ?? null) };\n},\n});\nasync function getUserName(ctx: QueryCtx, userId: Id<\"users\"> | null) {\nif (userId === null) {\nreturn null;\n}\nreturn (await ctx.db.get(userId))?.name;\n}\nYou can `export`\nhelpers to use them across multiple files. They will not be\ncallable from outside of your Convex functions.\n\nSee\n[Type annotating server side helpers](/production/best-practices/typescript#type-annotating-server-side-helpers)\nfor more guidance on TypeScript types.\n\n## Using NPM packages[](#using-npm-packages)\nQueries can import NPM packages installed in `node_modules`\n. Not all NPM\npackages are supported, see\n[Runtimes](/functions/runtimes#default-convex-runtime) for more\ndetails.\n\n`npm install @faker-js/faker`\n`import { query } from \"./_generated/server\";`\nimport { faker } from \"@faker-js/faker\";\nexport const randomName = query({\nargs: {},\nhandler: () => {\nfaker.seed();\nreturn faker.person.fullName();\n},\n});\n## Calling queries from clients[](#calling-queries-from-clients)\nTo call a query from [React](/client/react) use the\n[ useQuery](/client/react#loading-data) hook along with the generated\n\n[object.](/generated-api/api)\n`api`\n`import { useQuery } from \"convex/react\";`\nimport { api } from \"../convex/_generated/api\";\nexport function MyApp() {\nconst data = useQuery(api.myFunctions.sum, { a: 1, b: 2 });\n// do something with `data`\n}\nSee the [React](/client/react) client documentation for all the ways\nqueries can be called.\n\n## Caching & reactivity & consistency[](#caching--reactivity--consistency)\nQueries have three awesome attributes:\n\n**Caching**: Convex caches query results automatically. If many clients request the same query, with the same arguments, they will receive a cached response.**Reactivity**: clients can subscribe to queries to receive new results when the underlying data changes.**Consistency**: All database reads inside a single query call are performed at the same logical timestamp. Concurrent writes do not affect the query results.\nTo have these attributes the handler function must be *deterministic*, which\nmeans that given the same arguments (including the query context) it will return\nthe same response.\n\nFor this reason queries cannot `fetch`\nfrom third party APIs. To call third\nparty APIs, use [actions](/functions/actions).\n\nYou might wonder whether you can use non-deterministic language functionality\nlike `Math.random()`\nor `Date.now()`\n. The short answer is that Convex takes care\nof implementing these in a way that you don't have to think about the\ndeterministic constraint.\n\nSee [Runtimes](/functions/runtimes#default-convex-runtime) for more\ndetails on the Convex runtime.\n\n## Limits[](#limits)\nQueries have a limit to the amount of data they can read at once to guarantee\ngood performance. Check out these limits\n[here](/functions/error-handling/#database-limitations).\n\nFor information on other limits, see [here](/production/state/limits).",
        "metadata": {
            "title": "Queries | Convex Developer Hub",
            "url": "https://docs.convex.dev/functions/query-functions",
            "hostname": "convex.dev",
            "description": "Queries are the bread and butter of your backend API. They fetch data from the",
            "sitename": "docs.convex.dev",
            "date": "2024-01-01",
            "categories": [],
            "tags": [],
            "image": "https://docs.convex.dev/img/social.png",
            "filedate": "2024-12-01"
        }
    }
]