[
    {
        "url": "https://docs.convex.dev/functions/mutation-functions",
        "content": "# Mutations\nMutations insert, update and remove data from the database, check authentication or perform other business logic, and optionally return a response to the client application.\n\nThis is an example mutation, taking in named arguments, writing data to the database and returning a result:\n\n`import { mutation } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\n// Create a new task with the given text\nexport const createTask = mutation({\nargs: { text: v.string() },\nhandler: async (ctx, args) => {\nconst newTaskId = await ctx.db.insert(\"tasks\", { text: args.text });\nreturn newTaskId;\n},\n});\nRead on to understand how to build mutations yourself.\n\n## Mutation names[](#mutation-names)\nMutations follow the same naming rules as queries, see\n[Query names](/functions/query-functions#query-names).\n\nQueries and mutations can be defined in the same file when using named exports.\n\n## The `mutation`\nconstructor[](#the-mutation-constructor)\nTo declare a mutation in Convex use the `mutation`\nconstructor function. Pass it\nan object with a `handler`\nfunction, which performs the mutation:\n\n`import { mutation } from \"./_generated/server\";`\nexport const mutateSomething = mutation({\nhandler: () => {\n// implementation will be here\n},\n});\nUnlike a query, a mutation can but does not have to return a value.\n\n### Mutation arguments[](#mutation-arguments)\nJust like queries, mutations accept named arguments, and the argument values are\naccessible as fields of the second parameter of the `handler`\nfunction:\n\n`import { mutation } from \"./_generated/server\";`\nexport const mutateSomething = mutation({\nhandler: (_, args: { a: number; b: number }) => {\n// do something with `args.a` and `args.b`\n// optionally return a value\nreturn \"success\";\n},\n});\nArguments and responses are automatically serialized and deserialized, and you can pass and return most value-like JavaScript data to and from your mutation.\n\nTo both declare the types of arguments and to validate them, add an `args`\nobject using `v`\nvalidators:\n\n`import { mutation } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\nexport const mutateSomething = mutation({\nargs: { a: v.number(), b: v.number() },\nhandler: (_, args) => {\n// do something with `args.a` and `args.b`\n},\n});\nSee [argument validation](/functions/validation) for the full list of\nsupported types and validators.\n\nThe first parameter to the handler function is reserved for the mutation context.\n\n### Mutation responses[](#mutation-responses)\nQueries can return values of any supported\n[Convex type](/functions/validation) which will be automatically\nserialized and deserialized.\n\nMutations can also return `undefined`\n, which is not a valid Convex value. When a\nmutation returns `undefined`\n**it is translated to null** on the client.\n\n### Mutation context[](#mutation-context)\nThe `mutation`\nconstructor enables writing data to the database, and other\nConvex features by passing a\n[MutationCtx](/generated-api/server#mutationctx) object to the handler\nfunction as the first parameter:\n\n`import { mutation } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\nexport const mutateSomething = mutation({\nargs: { a: v.number(), b: v.number() },\nhandler: (ctx, args) => {\n// Do something with `ctx`\n},\n});\nWhich part of the mutation context is used depends on what your mutation needs to do:\n\n-\nTo read from and write to the database use the\n\n`db`\nfield. Note that we make the handler function an`async`\nfunction so we can`await`\nthe promise returned by`db.insert()`\n:convex/myFunctions.tsTS`import { mutation } from \"./_generated/server\";`\nimport { v } from \"convex/values\";\nexport const addItem = mutation({\nargs: { text: v.string() },\nhandler: async (ctx, args) => {\nawait ctx.db.insert(\"tasks\", { text: args.text });\n},\n});Read on about\n\n[Writing Data](/database/writing-data). -\nTo generate upload URLs for storing files use the\n\n`storage`\nfield. Read on about[File Storage](/file-storage). -\nTo check user authentication use the\n\n`auth`\nfield. Read on about[Authentication](/auth). -\nTo schedule functions to run in the future, use the\n\n`scheduler`\nfield. Read on about[Scheduled Functions](/scheduling/scheduled-functions).\n## Splitting up mutation code via helpers[](#splitting-up-mutation-code-via-helpers)\nWhen you want to split up the code in your mutation or reuse logic across multiple Convex functions you can define and call helper\n\n`import { v } from \"convex/values\";`\nimport { mutation, MutationCtx } from \"./_generated/server\";\nexport const addItem = mutation({\nargs: { text: v.string() },\nhandler: async (ctx, args) => {\nawait ctx.db.insert(\"tasks\", { text: args.text });\nawait trackChange(ctx, \"addItem\");\n},\n});\nasync function trackChange(ctx: MutationCtx, type: \"addItem\" | \"removeItem\") {\nawait ctx.db.insert(\"changes\", { type });\n}\nMutations can call helpers that take a\n[QueryCtx](/generated-api/server#queryctx) as argument, since the\nmutation context can do everything query context can.\n\nYou can `export`\nhelpers to use them across multiple files. They will not be\ncallable from outside of your Convex functions.\n\nSee\n[Type annotating server side helpers](/production/best-practices/typescript#type-annotating-server-side-helpers)\nfor more guidance on TypeScript types.\n\n## Using NPM packages[](#using-npm-packages)\nMutations can import NPM packages installed in `node_modules`\n. Not all NPM\npackages are supported, see\n[Runtimes](/functions/runtimes#default-convex-runtime) for more\ndetails.\n\n`npm install @faker-js/faker`\n`import { faker } from \"@faker-js/faker\";`\nimport { mutation } from \"./_generated/server\";\nexport const randomName = mutation({\nargs: {},\nhandler: async (ctx) => {\nfaker.seed();\nawait ctx.db.insert(\"tasks\", { text: \"Greet \" + faker.person.fullName() });\n},\n});\n## Calling mutations from clients[](#calling-mutations-from-clients)\nTo call a mutation from [React](/client/react) use the generated\n[ useMutation](/client/react#editing-data) hook:\n\nTo call a mutation from [React](/client/react) use the\n[ useMutation](/api/modules/react#usemutation) hook along with the generated\n\n[object.](/generated-api/api)\n`api`\n`import { useMutation } from \"convex/react\";`\nimport { api } from \"../convex/_generated/api\";\nexport function MyApp() {\nconst mutateSomething = useMutation(api.myFunctions.mutateSomething);\nconst handleClick = () => {\nmutateSomething({ a: 1, b: 2 });\n};\n// pass `handleClick` to a button\n// ...\n}\nSee the [React](/client/react) client documentation for all the ways\nqueries can be called.\n\nWhen mutations are called from the [React](/client/react) or\n[Rust](/client/rust) clients, they are executed one at a time in a single,\nordered queue. You don't have to worry about mutations editing the database in a\ndifferent order than they were triggered.\n\n## Transactions[](#transactions)\nMutations run **transactionally**. This means that:\n\n- All database reads inside the transaction get a consistent view of the data in the database. You don't have to worry about a concurrent update changing the data in the middle of the execution.\n- All database writes get committed together. If the mutation writes some data to the database, but later throws an error, no data is actually written to the database.\nFor this to work, similarly to queries, mutations must be deterministic, and\ncannot call third party APIs. To call third party APIs, use\n[actions](/functions/actions).\n\n## Limits[](#limits)\nMutations have a limit to the amount of data they can read and write at once to\nguarantee good performance. Check out these limits\n[here](/functions/error-handling/#database-limitations).\n\nFor information on other limits, see [here](/production/state/limits).",
        "metadata": {
            "title": "Mutations | Convex Developer Hub",
            "url": "https://docs.convex.dev/functions/mutation-functions",
            "hostname": "convex.dev",
            "description": "Mutations insert, update and remove data from the database, check authentication",
            "sitename": "docs.convex.dev",
            "date": "2024-01-01",
            "categories": [],
            "tags": [],
            "image": "https://docs.convex.dev/img/social.png",
            "filedate": "2024-12-01"
        }
    }
]